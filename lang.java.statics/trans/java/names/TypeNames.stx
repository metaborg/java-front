module java/names/TypeNames

imports

  signatures/java/names/Names-sig

  java/names/Main
  java/names/PackageNames
  java/names/PackageOrTypeNames
  java/types/Main
  java/types/ReferenceTypes


// 6.5.5 Meaning of Type Names

signature

  sorts
    TYPE_DECL  = (Id * scope)
    TYPE_PATH  = (path * TYPE_DECL)

  relations
    type     : Id -> scope
    thisType : TYPE_DECL


rules

  typeDeclId : TYPE_DECL -> Id

  typeDeclId((id, _)) = id.


  typeDeclScope : TYPE_DECL -> scope

  typeDeclScope((_, s_ty)) = typeScope(toType(s_ty)).


  typeDeclType : TYPE_DECL -> TYPE

  typeDeclType((_, s_ty)) = toType(s_ty).


  typeDeclKind : TYPE_DECL -> KIND

  typeDeclKind((_, s_ty)) = toKind(s_ty).


rules

  typeNameOk : scope * TypeName -> TYPE_DECL

  typeNameOk(s, typeName) = resolveTypeName(s, typeNameOk1(typeName)).

      typeNameOk1 : TypeName -> QID

      typeNameOk1(TypeName(id)) = ID(id).

      typeNameOk1(TypeName(pkgOrTypeName, id)) = QID(pkgOrTypeNameOk1(pkgOrTypeName), id).


  resolveTypeName : scope * QID -> TYPE_DECL

  resolveTypeName(s, ID(id)) = typeDecl :-
    typeDecl == singleTypeDecl(id, resolveLexicalTypeNames(s, id)).

  resolveTypeName(s, QID(qid, id)) = typeDecl :-
  {s_pkgOrType}
    s_pkgOrType == pkgOrTypeDeclScope(resolvePkgOrTypeName(s, qid)),
    typeDecl == singleTypeDecl(id, resolveMemberTypeNames(s_pkgOrType, id)).


  resolveLexicalTypeNames : scope * Id -> list(TYPE_PATH)

  resolveLexicalTypeNames(s, id) = typePathList :-
    query type
      filter /* lex type re */
          LEX* (IMP_PKG | IMP_ST | IMP_OD)? EXT* IMPL*
        and { id' :- id' == id }
      min /* type ord */
          $ < LEX, $ < IMP_PKG, $ < IMP_OD, $ < EXT, $ < IMPL,
          EXT < LEX, IMPL < LEX, IMP_PKG < LEX, IMP_ST < LEX, IMP_OD < LEX,
          IMP_ST < IMP_PKG, IMP_ST < IMP_OD,
          IMP_PKG < IMP_OD
        and true
      in s |-> typePathList,
    true.


  resolveMemberTypeNames : scope * Id -> list(TYPE_PATH)

  resolveMemberTypeNames(s, id) = typePathList :-
    query type
      filter /* mem type re */
          EXT* IMPL*
        and { id' :- id' == id }
      min /* type ord */
          $ < EXT, $ < IMPL
        and true
      in s |-> typePathList,
    true.


  singleTypeDecl : Id * list(TYPE_PATH) -> TYPE_DECL

  singleTypeDecl(id, []) = _ :-
    false | error $[Type [id] not found] @id.

  singleTypeDecl(id, [(_, typeDecl@(id', _))]) = typeDecl :-
    @id.ref := id'.

  singleTypeDecl(id, typeDeclList) = _ :-
    false | error $[Type [id] is ambiguous] @id.


  declareType : scope * Id * scope * KIND

  declareType(s, id, s_ty, K) :-
    setType(s_ty, REF(s_ty)),
    setKind(s_ty, K),
    !type[id, s_ty] in s,
    !thisType[(id, s_ty)] in s_ty,
    noOtherHomonymousType(s, (id, s_ty)),
    noEnclosingHomonymousType(s, id),
    noHomonymousPkg(s, id),
    true.


  aliasType : scope * TYPE_DECL

  aliasType(s, (id, s_ty)) :-
    !type[id, s_ty] in s.


  this : scope -> TYPE_DECL

  this(s) = typeDecl :-
    query thisType
      filter LEX* and true
      min $ < LEX and true
      in s |-> [(_, typeDecl)].


  qualThis : TYPE_DECL * scope -> TYPE_DECL

  qualThis(typeDecl, s) = typeDecl' :-
    query thisType
      filter LEX* and { typeDecl' :- typeDecl' == typeDecl }
      min $ < LEX and true
      in s |-> [(_, typeDecl')].


  super : TYPE_DECL -> TYPE_DECL

  super(typeDecl) = typeDecl' :-
  {s_ty}
    s_ty == typeDeclScope(typeDecl),
    query thisType
      filter EXT and true
      in s_ty |-> [(_, typeDecl')].


  noOtherHomonymousType: scope * TYPE_DECL
  
  noOtherHomonymousType(s, typeDecl@(id, _)) :-
    query type
      filter e and { id' :- id' == id }
      in s |-> [(_, typeDecl)].


  noEnclosingHomonymousType : scope * Id

  noEnclosingHomonymousType(s, id) :-
    query thisType
      filter LEX* and { (id', _) :- id' == id }
      in s |-> [].

