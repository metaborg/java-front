module refret/intellij/inlineObject/InlineBitString_after

test InlineBitString_after: parsing [[
  test;
  [Test]
      class Main {
        BitString test(long result, long mask) {
            BitString intersection = null;
            BitString other = null;
            long intersectMask = mask & other.myMask;
            if ((result & mask & intersectMask) == (other.myBits & intersectMask)) {
                intersection = new BitString(result & mask | other.myBits, mask | other.myMask);
            }
            assert intersection != null;
            return intersection;
        }
    }
  
    class BitString {
        final long myBits;
        final long myMask;
  
        BitString(long bits, long mask) {
            myBits = bits & mask;
            myMask = mask;
        }
        BitString intersect(BitString other) {
            long intersectMask = myMask & other.myMask;
            if ((myBits & intersectMask) != (other.myBits & intersectMask)) return null;
            return new BitString(myBits | other.myBits, myMask | other.myMask);
        }
    }
]] parse succeeds

test InlineBitString_after: default analysis [[
  test;
  [Test]
      class Main {
        BitString test(long result, long mask) {
            BitString intersection = null;
            BitString other = null;
            long intersectMask = mask & other.myMask;
            if ((result & mask & intersectMask) == (other.myBits & intersectMask)) {
                intersection = new BitString(result & mask | other.myBits, mask | other.myMask);
            }
            assert intersection != null;
            return intersection;
        }
    }
  
    class BitString {
        final long myBits;
        final long myMask;
  
        BitString(long bits, long mask) {
            myBits = bits & mask;
            myMask = mask;
        }
        BitString intersect(BitString other) {
            long intersectMask = myMask & other.myMask;
            if ((myBits & intersectMask) != (other.myBits & intersectMask)) return null;
            return new BitString(myBits | other.myBits, myMask | other.myMask);
        }
    }
]] analysis succeeds

test InlineBitString_after: test analysis [[
  test;
  [Test]
      class Main {
        BitString test(long result, long mask) {
            BitString intersection = null;
            BitString other = null;
            long intersectMask = mask & other.myMask;
            if ((result & mask & intersectMask) == (other.myBits & intersectMask)) {
                intersection = new BitString(result & mask | other.myBits, mask | other.myMask);
            }
            assert intersection != null;
            return intersection;
        }
    }
  
    class BitString {
        final long myBits;
        final long myMask;
  
        BitString(long bits, long mask) {
            myBits = bits & mask;
            myMask = mask;
        }
        BitString intersect(BitString other) {
            long intersectMask = myMask & other.myMask;
            if ((myBits & intersectMask) != (other.myBits & intersectMask)) return null;
            return new BitString(myBits | other.myBits, myMask | other.myMask);
        }
    }
]] run test-analyze to SUCCEED()

test InlineBitString_after: refret test 1 [[
  test;
  [Test]
      class Main {
        BitString test(long result, long mask) {
            BitString intersection = null;
            BitString [[other]] = null;
            long intersectMask = mask & other.myMask;
            if ((result & mask & intersectMask) == (other.myBits & intersectMask)) {
                intersection = new BitString(result & mask | [[myBits]], mask | other.myMask);
            }
            assert intersection != null;
            return intersection;
        }
    }
  
    class BitString {
        final long [[myBits]];
        final long myMask;
  
        BitString(long bits, long mask) {
            myBits = bits & mask;
            myMask = mask;
        }
        BitString intersect(BitString other) {
            long intersectMask = myMask & other.myMask;
            if ((myBits & intersectMask) != (other.myBits & intersectMask)) return null;
            return new BitString(myBits | other.myBits, myMask | other.myMask);
        }
    }
]] run fix-reference(|#2, #3, #1) to [[
  test;
  [Test]
      class Main {
        BitString test(long result, long mask) {
            BitString intersection = null;
            BitString other = null;
            long intersectMask = mask & other.myMask;
            if ((result & mask & intersectMask) == (other.myBits & intersectMask)) {
                intersection = new BitString(result & mask | other.myBits, mask | other.myMask);
            }
            assert intersection != null;
            return intersection;
        }
    }
  
    class BitString {
        final long myBits;
        final long myMask;
  
        BitString(long bits, long mask) {
            myBits = bits & mask;
            myMask = mask;
        }
        BitString intersect(BitString other) {
            long intersectMask = myMask & other.myMask;
            if ((myBits & intersectMask) != (other.myBits & intersectMask)) return null;
            return new BitString(myBits | other.myBits, myMask | other.myMask);
        }
    }
]]

test InlineBitString_after: refret test 2 [[
  test;
  [Test]
      class Main {
        BitString test(long result, long mask) {
            BitString intersection = null;
            BitString [[other]] = null;
            long intersectMask = mask & other.myMask;
            if ((result & mask & intersectMask) == (other.myBits & intersectMask)) {
                intersection = new BitString(result & mask | other.myBits, mask | [[myMask]]);
            }
            assert intersection != null;
            return intersection;
        }
    }
  
    class BitString {
        final long myBits;
        final long [[myMask]];
  
        BitString(long bits, long mask) {
            myBits = bits & mask;
            myMask = mask;
        }
        BitString intersect(BitString other) {
            long intersectMask = myMask & other.myMask;
            if ((myBits & intersectMask) != (other.myBits & intersectMask)) return null;
            return new BitString(myBits | other.myBits, myMask | other.myMask);
        }
    }
]] run fix-reference(|#2, #3, #1) to [[
  test;
  [Test]
      class Main {
        BitString test(long result, long mask) {
            BitString intersection = null;
            BitString other = null;
            long intersectMask = mask & other.myMask;
            if ((result & mask & intersectMask) == (other.myBits & intersectMask)) {
                intersection = new BitString(result & mask | other.myBits, mask | other.myMask);
            }
            assert intersection != null;
            return intersection;
        }
    }
  
    class BitString {
        final long myBits;
        final long myMask;
  
        BitString(long bits, long mask) {
            myBits = bits & mask;
            myMask = mask;
        }
        BitString intersect(BitString other) {
            long intersectMask = myMask & other.myMask;
            if ((myBits & intersectMask) != (other.myBits & intersectMask)) return null;
            return new BitString(myBits | other.myBits, myMask | other.myMask);
        }
    }
]]

