module refret/intellij/inlineObject/InlineBitString_after

test parse: InlineBitString_after [[
  test;
  [Test]
      class Main {
        BitString test(long result, long mask) {
            BitString intersection = null;
            BitString other = super.getBitwiseMask();
            long intersectMask = mask & other.myMask;
            if ((result & mask & intersectMask) == (other.myBits & intersectMask)) {
                intersection = new BitString(result & mask | other.myBits, mask | other.myMask);        // TODO: Context
            }
            assert intersection != null;
            return intersection;
        }
    }
  
    class BitString {
        final long myBits;
        final long myMask;
  
        BitString(long bits, long mask) {
            myBits = bits & mask;
            myMask = mask;
        }
        BitString intersect(BitString other) {
            long intersectMask = myMask & other.myMask;
            if ((myBits & intersectMask) != (other.myBits & intersectMask)) return null;
            return new BitString(myBits | other.myBits, myMask | other.myMask);
        }
    }
]] parse succeeds

test analysis: InlineBitString_after [[
  test;
  [Test]
      class Main {
        BitString test(long result, long mask) {
            BitString intersection = null;
            BitString other = super.getBitwiseMask();
            long intersectMask = mask & other.myMask;
            if ((result & mask & intersectMask) == (other.myBits & intersectMask)) {
                intersection = new BitString(result & mask | other.myBits, mask | other.myMask);        // TODO: Context
            }
            assert intersection != null;
            return intersection;
        }
    }
  
    class BitString {
        final long myBits;
        final long myMask;
  
        BitString(long bits, long mask) {
            myBits = bits & mask;
            myMask = mask;
        }
        BitString intersect(BitString other) {
            long intersectMask = myMask & other.myMask;
            if ((myBits & intersectMask) != (other.myBits & intersectMask)) return null;
            return new BitString(myBits | other.myBits, myMask | other.myMask);
        }
    }
]] run test-analyze to SUCCEED()

test refret 0: InlineBitString_after [[
  test;
  [Test]
      class Main {
        BitString test(long result, long mask) {
            BitString intersection = null;
            BitString other = super.getBitwiseMask();
            long intersectMask = mask & other.myMask;
            if ((result & mask & intersectMask) == (other.myBits & intersectMask)) {
                intersection = new BitString(result & mask | [[myBits]], mask | other.myMask);        // TODO: Context
            }
            assert intersection != null;
            return intersection;
        }
    }
  
    class BitString {
        final long [[myBits]];
        final long myMask;
  
        BitString(long bits, long mask) {
            myBits = bits & mask;
            myMask = mask;
        }
        BitString intersect(BitString other) {
            long intersectMask = myMask & other.myMask;
            if ((myBits & intersectMask) != (other.myBits & intersectMask)) return null;
            return new BitString(myBits | other.myBits, myMask | other.myMask);
        }
    }
]] run fix-reference(|#1, #2) to [[
  test;
  [Test]
      class Main {
        BitString test(long result, long mask) {
            BitString intersection = null;
            BitString other = super.getBitwiseMask();
            long intersectMask = mask & other.myMask;
            if ((result & mask & intersectMask) == (other.myBits & intersectMask)) {
                intersection = new BitString(result & mask | other.myBits, mask | other.myMask);        // TODO: Context
            }
            assert intersection != null;
            return intersection;
        }
    }
  
    class BitString {
        final long myBits;
        final long myMask;
  
        BitString(long bits, long mask) {
            myBits = bits & mask;
            myMask = mask;
        }
        BitString intersect(BitString other) {
            long intersectMask = myMask & other.myMask;
            if ((myBits & intersectMask) != (other.myBits & intersectMask)) return null;
            return new BitString(myBits | other.myBits, myMask | other.myMask);
        }
    }
]]

test refret 1: InlineBitString_after [[
  test;
  [Test]
      class Main {
        BitString test(long result, long mask) {
            BitString intersection = null;
            BitString other = super.getBitwiseMask();
            long intersectMask = mask & other.myMask;
            if ((result & mask & intersectMask) == (other.myBits & intersectMask)) {
                intersection = new BitString(result & mask | other.myBits, mask | [[myMask]]);        // TODO: Context
            }
            assert intersection != null;
            return intersection;
        }
    }
  
    class BitString {
        final long myBits;
        final long [[myMask]];
  
        BitString(long bits, long mask) {
            myBits = bits & mask;
            myMask = mask;
        }
        BitString intersect(BitString other) {
            long intersectMask = myMask & other.myMask;
            if ((myBits & intersectMask) != (other.myBits & intersectMask)) return null;
            return new BitString(myBits | other.myBits, myMask | other.myMask);
        }
    }
]] run fix-reference(|#1, #2) to [[
  test;
  [Test]
      class Main {
        BitString test(long result, long mask) {
            BitString intersection = null;
            BitString other = super.getBitwiseMask();
            long intersectMask = mask & other.myMask;
            if ((result & mask & intersectMask) == (other.myBits & intersectMask)) {
                intersection = new BitString(result & mask | other.myBits, mask | other.myMask);        // TODO: Context
            }
            assert intersection != null;
            return intersection;
        }
    }
  
    class BitString {
        final long myBits;
        final long myMask;
  
        BitString(long bits, long mask) {
            myBits = bits & mask;
            myMask = mask;
        }
        BitString intersect(BitString other) {
            long intersectMask = myMask & other.myMask;
            if ((myBits & intersectMask) != (other.myBits & intersectMask)) return null;
            return new BitString(myBits | other.myBits, myMask | other.myMask);
        }
    }
]]

