module refret/references

imports

  strategolib

  signatures/syntax/java/lexical/-
  signatures/syntax/java/names/-
  signatures/syntax/java/expressions/-
  signatures/syntax/java/types/-
  signatures/syntax/java/classes/-
  signatures/syntax/java/packages/-

  injections/syntax/java/expressions/-

  refret/util

rules // recognize references, based on syntax/java/names/Names.sdf3

  collect-ref = collect-one(where(strip-annos; dbg; is-name-of-sort; dbg); dbg(!"suc-where: ")); dbg(!"suc: ")

  is-name-of-sort :: ? -> string
  is-name-of-sort: ClassType(_, _, _) -> "ClassType"
  is-name-of-sort: ClassOrInterfaceTypeMember(_, _, _, _) -> "ClassType"
  is-name-of-sort: UnannClassType(_, _) -> "UnannClassType"
  is-name-of-sort: UnannClassOrInterfaceTypeMember(_, _, _, _) -> "UnannClassType"

  is-name-of-sort: ExpressionName2Expression(_) -> "Expression"
  is-name-of-sort: ExpressionName(_)            -> "ExpressionName"
  is-name-of-sort: QExpressionName(_, _)        -> "ExpressionName"

  is-name-of-sort: ExpressionName2LHS(_) -> "LHS"
  is-name-of-sort: FieldAccess2LHS(_) -> "LHS"
  is-name-of-sort: ArrayAccess2LHS(_) -> "LHS"

  // methods
  // FIXME: MethodInvocationExpression is not a sort, but is required to distinguish
  // method calls from references in method call arguments.
  is-name-of-sort: Invoke(_, _) -> "MethodInvocationExpression"
  is-name-of-sort: InvokeQExp(_, _, _, _) -> "MethodInvocationExpression"
  is-name-of-sort: InvokeSuper(_, _, _) -> "MethodInvocationExpression"
  is-name-of-sort: InvokeQSuper(_, _, _, _) -> "MethodInvocationExpression"

  is-name-of-sort: NewInstance(_, _, _, _, _, _) -> "UnqualifiedInstance"
  is-name-of-sort: NewInstanceWithInitializer(_, _, _, _, _, _, _) -> "UnqualifiedInstance"

  is-name-of-sort: SingleTypeImport(_) -> "ImportDeclaration"
  is-name-of-sort: SingleStaticImport(_, _) -> "ImportDeclaration"

  is-name-of-sort: AltConstrInv(_, _) -> "ConstructorInvocation"
  is-name-of-sort: SuperConstrInv(_, _) -> "ConstructorInvocation"
  is-name-of-sort: ExprNameConstrInv(_, _, _) -> "ConstructorInvocation"

  // Collect rightmost leaf if it is an `Id(_)` term
  collect-id :: ? -> Id

  collect-id = ?Id(_)

  collect-id = ?ClassType(_, <collect-id>, _) + ?ClassOrInterfaceTypeMember(_, _, <collect-id>, _)
  collect-id = ?UnannClassType(<collect-id>, _) + ?UnannClassOrInterfaceTypeMember(_, _, <collect-id>, _)

  collect-id = ?VariableDecl(<collect-id>) + ?VariableDeclInit(<collect-id>, _)

  collect-id = ?Invoke(<collect-id>, _) + ?InvokeQExp(_, _, <collect-id>, _) + ?InvokeSuper(_, <collect-id>, _) + ?InvokeQSuper(_, _, <collect-id>, _)

  collect-id = ?EnumConstNoBody(_, <collect-id>, _) + ?EnumConst(_, <collect-id>, _, _)

  collect-id = ?NewInstance(_, _, <collect-id>, _, _, _) + ?NewInstance(_, _, _, <last; collect-id>, _, _)
  collect-id = ?NewInstanceWithInitializer(_, _, <collect-id>, _, _, _, _)
  				 + ?NewInstanceWithInitializer(_, _, _, <last; collect-id>, _, _, _)

  collect-id = get-arguments; last; dbg; collect-id
