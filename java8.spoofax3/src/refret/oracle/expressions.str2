module refret/oracle/expressions

imports

  strategolib

  statix/api
  statix/runtime/-

  refret/-
  refret/oracle/-

  signatures/syntax/java/lexical/-
  signatures/syntax/java/names/-
  signatures/syntax/java/types/-
  signatures/syntax/java/expressions/-

  injections/syntax/java/expressions/-
  injections/syntax/java/types/-

rules

  qualify-expression(|?, string, blob) :: ? -> List(Expression * ?)
  qualify-expression(|tgt, sortName, a): (inst, e) -> <map(!(<id>, ref-idx))> prop*
    with               <debug> sortName
       ; x          := <collect-id> e
       ; ref-idx    := <stx--get-ast-index> x
       ; s-ref      := <scope-prop(|a)> x
       ; s-tgt      := <scope-prop(|a); escape-static(|a)> tgt
       ; s-prop*    := <reconstruct-static-names(|a, x)> s-tgt
       ; inst'      := <to-opt-expr> inst
       ; q-prop*    := <qualify-instance-field(|a, x)> (inst', s-ref)
       ; prop*      := <flatten-list> 
                       [ [ e ]
                       , s-prop*
                       , q-prop*
                       ]

  to-opt-expr :: Option(?) -> Option(Expression)
  to-opt-expr = is(Option(Expression))
  to-opt-expr = ?Some(<id>); collect-id; !Some(ExpressionName2Expression(ExpressionName(<id>)))

  // static accesses
  reconstruct-static-names(|blob, Id) :: Term -> List(Expression)
  reconstruct-static-names(|a, x): s-tgt -> prop*
    with q-name*   := <this-type(|a); reconstruct-static-qualifiers(|a)> s-tgt
       ; prop*     := <map(mk-expr-name(|x); !ExpressionName2Expression(<id>))> q-name*

  mk-expr-name(|Id) :: QName -> ExpressionName
  mk-expr-name(|x): QName(x*) -> QExpressionName(q, x)
    with q := <foldl'(!AmbiguousName(<id>), { n, q: ?(n, q); !QAmbiguousName(q, n) })> x*

  // field access with given instance
  qualify-instance-field(|blob, Id) :: Option(Expression) * Term -> List(Expression)
  qualify-instance-field(|a, x): (Some(inst), s-ref) -> prop*
    with q-prop* := <reconstruct-field-access(|a, x)> s-ref
       ; c-prop* := <this-type(|a); insert-casts(|a, inst, x)> s-ref
       ; prop*   := [ FieldAccess2Expression(Field(inst, x))
                    , c-prop*
                    ]
  qualify-instance-field(|a, x): (None(), s-ref) -> prop*
    with q-prop* := <reconstruct-field-access(|a, x)> s-ref
       ; prop*   := [ FieldAccess2Expression(Field(This(), x))
                    , FieldAccess2Expression(SuperField(x))
                    | q-prop*
                    ]

  // this/super field accesses
  reconstruct-field-access(|blob, Id) :: Term -> List(Expression)
  reconstruct-field-access(|a, x): s-ref -> prop*
    with T            := <this-type(|a)> s-ref
       ; e-cls*       := <reconstruct-enclosing-classes(|a)> T
       ; e-cls'*      := <map(Fst); reverse; Tl> e-cls*
       ; this-prop*   := <map(mk-this-prop(|x))> e-cls'*
       ; super-prop*  := <map(mk-super-prop(|x))> e-cls'*
       ; cast-prop*   := <reconstruct-super-classes(|a); (Tl; Tl; map(insert-casts(|a, This(), x))) <+ ![]> T
       ; c-this-prop* := <flatmap(mk-casted-this-prop(|a, x))> e-cls*
       ; prop*        := <flatten-list> [this-prop*, super-prop*, cast-prop*, c-this-prop*]

  mk-this-prop(|Id) :: Id -> Expression
  mk-this-prop(|x): q -> FieldAccess2Expression(Field(QThis(TypeName(q)), x))

  mk-casted-this-prop(|blob, Id) :: Id * Term -> List(Expression)
  mk-casted-this-prop(|a, x): T@(x-T, s-T) -> prop*
    with if super* := <reconstruct-super-classes(|a); Tl; Tl> T then
           prop* := <map(insert-casts(|a, QThis(TypeName(x-T)), x))> super*
         else
           prop* := []
         end

  mk-super-prop(|Id) :: Id -> Expression
  mk-super-prop(|x): q -> FieldAccess2Expression(QSuperField(TypeName(q), x))

  mk-type-name :: QName -> TypeName
  mk-type-name: QName([x]) -> TypeName(x)
  mk-type-name: QName(xs) -> QTypeName(q, x)
    with (x*, x) := <split-init-last> xs
       ; q       := <foldl'(!PackageOrTypeName(<id>), { n, q: ?(n, q); !QPackageOrTypeName(q, n) })> x*

  // superclass casts
  insert-casts(|blob, Expression, Id) :: Id * Term -> List(Expression)
  insert-casts(|a, expr, x) : T@(x-T, s-T) -> prop*
    with p-cls* := <reconstruct-super-classes(|a); reverse; Tl> T
       ; prop*  := <flatmap(reconstruct-static-qualifiers(|a)); map(mk-cast(|expr); mk-field-access(|x))> p-cls*

  mk-field-access(|Id) :: Expression -> Expression
  mk-field-access(|x): expr -> FieldAccess2Expression(Field(expr, x))

  mk-cast(|Expression) :: QName -> Expression
  mk-cast(|expr): qn -> CastReference(ClassType2ReferenceType(ct), [], expr)
    with ct := <mk-qualified-class-type(|[], NoTypeArguments())> qn

