module refret/oracle/expressions

imports

  strategolib

  statix/api
  statix/runtime/-

  refret/-
  refret/oracle/-

  signatures/syntax/java/lexical/-
  signatures/syntax/java/names/-
  signatures/syntax/java/types/-
  signatures/syntax/java/expressions/-

  injections/syntax/java/expressions/-
  injections/syntax/java/types/-

rules

  qualify-expression(|?, string, blob) :: ? -> List(Expression * ?)
  qualify-expression(|tgt, sortName, a): (inst, e) -> prop*
    with               <debug> sortName
       ; x          := <collect-id> e
       ; ref-idx    := <stx--get-ast-index> x
       ; s-ref      := <dbg(!"co-gsp"); collect-om(gen-scope-prop(|a)); dbg(!"res: "); Hd> e
       ; s-tgt      := <scope-prop(|a); escape-static(|a)> tgt
       ; id-prop    := <gen-id-prop(|e, ref-idx)> inst 
       ; s-prop     := <reconstruct-static-names(|a, x); map(pair-ref-idx(|ref-idx))> s-tgt
       ; inst'      := <to-opt-expr> inst
       ; q-prop     := <qualify-instance-field(|a, x, e, ref-idx)> (inst', s-ref)
       ; prop*      := <flatten> [id-prop, s-prop, q-prop]

  gen-id-prop(|a, ?)   :: Option(?) -> List(a * ?)
  gen-id-prop(|e, ref-idx): None()  -> [(e, ref-idx)]
  gen-id-prop(|e, ref-idx): Some(_) -> []

  to-opt-expr :: Option(?) -> Option(Expression)
  to-opt-expr = is(Option(ExpressionName)); ?Some(<id>); !Some(ExpressionName2Expression(<id>))
  to-opt-expr = is(Option(Expression))
  to-opt-expr = ?Some(<id>); collect-id; !Some(ExpressionName2Expression(ExpressionName(<id>)))

  // static accesses
  reconstruct-static-names(|blob, Id) :: Term -> List(Expression)
  reconstruct-static-names(|a, x): s-tgt -> prop*
    with if T := <this-type(|a)> s-tgt then
           prop* := <reconstruct-static-qualifiers(|a); map(mk-expr-name(|x); !ExpressionName2Expression(<id>))> T
         else
           prop* := []
         end

  mk-expr-name :: QName -> ExpressionName
  mk-expr-name : QName(xs) -> name
    with (x*, x') := <dbg(!"mk-expr-1: "); split-init-last; dbg(!"mk-expr-2: ")> xs
       ; name     := <dbg(!"mk-expr-3: "); mk-expr-name(|x'); dbg(!"mk-expr-4: ")> QName(x*)

  mk-expr-name(|Id) :: QName -> ExpressionName
  mk-expr-name(|x): QName(x*) -> QExpressionName(q, x)
    with q := <foldl'(!AmbiguousName(<id>), { n, q: ?(n, q); !QAmbiguousName(q, n) })> x*

  // field access with given instance
  qualify-instance-field(|blob, Id, Expression, ?) :: Option(Expression) * Term -> List(Expression * ?)
  qualify-instance-field(|a, x, e, ref-idx): (Some(inst), s-ref) -> prop*
    with // s-recv  := <expr-type-scope(|a)> (s-ref, inst)
         c-prop  := <this-type(|a); insert-casts(|a, inst, x)> s-ref
       ; prop*   := <map(pair-ref-idx(|ref-idx))> [ <mk-field-access(|x)> inst | c-prop]

  qualify-instance-field(|a, x, e, ref-idx): (None(), s-ref) -> prop*
    with q-prop* := <reconstruct-field-access(|a, x, ref-idx)> s-ref
       ; prop*   := [ (FieldAccess2Expression(Field(This(), x)), ref-idx)
                    , (FieldAccess2Expression(SuperField(x)), ref-idx)
                    , (QThis(TypeName(x)), ref-idx)
                    | q-prop*
                    ]

  // this/super field accesses
  reconstruct-field-access(|blob, Id, ?) :: Term -> List(Expression * ?)
  reconstruct-field-access(|a, x, ref-idx): s-ref -> prop'*
    with T            := <this-type(|a)> s-ref
       ; e-cls*       := <reconstruct-enclosing-classes(|a)> T
       ; e-cls'*      := <map(Fst); reverse; Tl> e-cls*
       ; this-prop*   := <map(mk-this-prop(|x))> e-cls'*
       ; super-prop*  := <map(mk-super-prop(|x))> e-cls'*
       ; cast-prop*   := <reconstruct-super-classes(|a); (Tl; Tl; map(insert-casts(|a, This(), x))) <+ ![]> T
       ; c-this-prop* := <flatmap(mk-casted-this-prop(|a, x))> e-cls*
       ; this-ref*    := <map(!(QThis(TypeName(<id>)), <stx--get-ast-index>))> e-cls'*
       ; prop*        := <flatten-list; map(pair-ref-idx(|ref-idx))> [this-prop*, super-prop*, cast-prop*, c-this-prop*]
       ; prop'*       := <flatten-list> [prop*, this-ref*]

  mk-this-prop(|Id) :: Id -> Expression
  mk-this-prop(|x): q -> FieldAccess2Expression(Field(QThis(TypeName(q)), x))

  mk-casted-this-prop(|blob, Id) :: Id * Term -> List(Expression)
  mk-casted-this-prop(|a, x): T@(x-T, s-T) -> prop*
    with if super* := <reconstruct-super-classes(|a); Tl; Tl> T then
           prop* := <map(insert-casts(|a, QThis(TypeName(x-T)), x))> super*
         else
           prop* := []
         end

  mk-super-prop(|Id) :: Id -> Expression
  mk-super-prop(|x): q -> FieldAccess2Expression(QSuperField(TypeName(q), x))

  mk-type-name :: QName -> TypeName
  mk-type-name: QName([x]) -> TypeName(x)
  mk-type-name: QName(xs) -> QTypeName(q, x)
    with (x*, x) := <split-init-last> xs
       ; q       := <foldl'(!PackageOrTypeName(<id>), { n, q: ?(n, q); !QPackageOrTypeName(q, n) })> x*

  // superclass casts
  insert-casts(|blob, Expression, Id) :: Id * Term -> List(Expression)
  insert-casts(|a, expr, x) : T@(x-T, s-T) -> prop*
    with p-cls* := <dbg(!"cast-T: "); reconstruct-super-classes(|a); dbg(!"super-T"); reverse; Tl> T
       ; prop*  := <flatmap(dbg(!"type:"); reconstruct-static-qualifiers(|a); dbg(!"q-types: ")); map(mk-cast(|expr); mk-field-access(|x)); dbg(!"c-props: ")> p-cls*

  mk-field-access(|Id) :: Expression -> Expression
  mk-field-access(|x): ExpressionName2Expression(ExpressionName(q)) -> ExpressionName2Expression(QExpressionName(AmbiguousName(q), x))
  mk-field-access(|x): ExpressionName2Expression(QExpressionName(q, x')) -> ExpressionName2Expression(QExpressionName(QAmbiguousName(q, x'), x))
  mk-field-access(|x): expr -> FieldAccess2Expression(Field(expr, x))

  mk-cast(|Expression) :: QName -> Expression
  mk-cast(|expr): qn -> CastReference(ClassType2ReferenceType(ct), [], expr)
    with ct := <mk-qualified-class-type(mk-single-class-type, mk-composite-class-type|[], NoTypeArguments())> qn

