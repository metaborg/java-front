module refret

imports

  java/Main
  java/names/Main
  java/names/TypeNames
  java/types/ReferenceTypes
  java/expressions/Main

  signatures/start-sig
  main

rules

  namedTypeScope: scope * Id -> scope
  namedTypeScope(s, x) = typeDeclScope(T) :-
    query type
      filter STATIC_MEMBERS? and { x' :- x' == x }
          in s |-> [(_, T)].

  thisDecl: scope -> TYPE_DECL
  thisDecl(s) = typeDecl :-
    query thisType
      filter INSTANCE_LEX? LEX* STATIC_LEX*
         min $ < LEX, LEX < STATIC_LEX
          in s |-> [(_, typeDecl)].

  escapeStatic: scope -> scope
  escapeStatic(s) = s' :-
    query () 
      filter INSTANCE_LEX?
         min INSTANCE_LEX < $
          in s |-> [(_, s')].

  enclosingClass: scope -> (Id * scope)
  enclosingClass(s) = (typeDeclId(T), dst(p)) :-
    query thisType
      filter (INSTANCE_LEX? LEX* STATIC_LEX*) & ~e
         min $ < LEX, LEX < STATIC_LEX
          in s |-> [(p, T)].

  superClass: scope -> TYPE_DECL
  superClass(s) = superTypeDecl :- {s' thisTypeDecl}
    escapeStatic(s) == s',
    thisTypeDecl == this(s'),
    superTypeDecl == super(thisTypeDecl).

  expressionTypeScope : scope * Expression -> scope
  expressionTypeScope(s, e) = typeScope(exprOk(s, e)).

  validate: Start -> ()
  validate(ast) = () :- programOk(ast).  

  dst : path -> scope
  dst(_PathEmpty(s)) = s.
  dst(_PathStep(_, _, s)) = s.
