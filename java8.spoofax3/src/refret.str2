module refret

imports
  strategolib
  statix/runtime/-
  statix/api

  libstratego-aterm

imports

  signatures/syntax/java/lexical/-
  signatures/syntax/java/names/-
  signatures/syntax/java/types/-
  injections/-

rules

  // Names are hardcoded in current implementation
  implicate-injections-tiger = implicate-injections-java8
  explicate-injections-tiger = explicate-injections-java8

rules

  fix-reference(|ref, tgt): ast -> ast'
    // retrieve original analysis
    with a       := <stx--get-ast-analysis> ast

    // retrieve indices of reference to test
    with ref'    := <collect-ref; collect-id> ref
       ; tgt'    := <collect-ref; collect-id> tgt
       ; ref-idx := <stx--get-ast-index> ref'

    // lock indicated reference, create placeholder and fix!
    with ast'    := < explicate-injections-java8-Start
                    ; rr-create-placeholder(|ref-idx, tgt', a)
                    ; rr--fix-references(|a)
                    // ; where(pp-aterm; dbg)
                    ; implicate-injections-java8-Start
                    > ast

rules // recognize references, based on syntax/java/names/Names.sdf3

  collect-ref = collect-one(where(strip-annos; is-name-of-sort))

  is-name-of-sort: ClassType(_, _, _) -> "ClassType"
  is-name-of-sort: ClassOrInterfaceTypeMember(_, _, _, _) -> "ClassType"

  is-name-of-sort: PackageName(_) -> "PackageName"
  is-name-of-sort: QPackageName(_, _) -> "PackageName"

  is-name-of-sort: TypeName(_) -> "TypeName"
  is-name-of-sort: QTypeName(_, _) -> "TypeName"

  is-name-of-sort: PackageOrTypeName(_) -> "PackageOrTypeName"
  is-name-of-sort: QPackageOrTypeName(_, _) -> "PackageOrTypeName"

  is-name-of-sort: ExpressionName(_) -> "ExpressionName"
  is-name-of-sort: QExpressionName(_, _) -> "ExpressionName"

  is-name-of-sort: AmbiguousName(_) -> "AmbiguousName"
  is-name-of-sort: QAmbiguousName(_, _) -> "AmbiguousName"

  is-name-of-sort: MethodName(_) -> "MethodName"

  is-name-of-sort: Id(_) -> "Id"

  // Collect rightmost leaf if it is an `Id(_)` term
  collect-id = ?Id(_)
  collect-id = ?ClassType(_, <collect-id>, _)
  collect-id = ?ClassOrInterfaceTypeMember(_, _, <collect-id>, _)
  collect-id = where(is-name-of-sort; not(equal(|"ClassType"))); get-arguments; last; collect-id


rules // qualifier oracle

  qualify-reference(|ctxs, sortName, a): ref -> prop*
    with [tgt]   := ctxs
       ; ref-idx := <collect-id; stx--get-ast-index> ref
       ; prop*   := <qualify-class-reference(|tgt, sortName, a) <+ ![(ref, ref-idx)]> ref

signature // Qualified names (wrapper around `List(Id)`, used to prevent issues with `reverse` flattening nested lists.

  sorts QName constructors
    QName: List(Id) -> QName

rules

  mk-qnames :: List(Id) -> List(QName)
  mk-qnames: l@[x]      -> [QName(l)]
  mk-qnames: l@[h|tl]   -> [QName(l)|tl*]
    with tl* := <mk-qnames> tl

  prefix-qname :: List(Id) * QName -> QName
  prefix-qname: (x*, QName(qn)) -> QName(<at-end(!qn)> x*)

rules // classes and packages

  qualify-class-reference(|tgt, sortName, a): t@ClassType(ann*, x, tp*) -> prop*
    with ref-idx    := <stx--get-ast-index> x
       ; s-tgt      := <stx-get-ast-property(|a, "scope")> tgt
       ; (cls*, s)  := <reconstruct-enclosing-classes(|a)> (x, s-tgt)
       ; q-cls*     := <mk-qnames> cls*
       ; (p, s-pkg) := <this-pkg(|a)> s
	   ; pkg*       := <reconstruct-package(|a); filter(not(?Id("(unnamed)")))> (p, s-pkg)
	   ; fq-cls     := <prefix-qname> (pkg*, <Hd> q-cls*)
	   ; p-cls*     := <reverse> [fq-cls, q-cls*] /* Proposal order: classes in increasing order of enclosing class qualifier + FQ class + pkg */
	   ; q-cls      := <map(mk-qualified-class-type(|ann*, tp*)); make-set> p-cls*
	   ; prop*      := <map(!(<id>, ref-idx))> q-cls

  // packages
  reconstruct-package(|blob) :: Id * Term -> List(Id)
  reconstruct-package(|a): p@(pkg-name, s-pkg) -> res
    with if <super-pkg(|a)> p => (p', s-pkg') then
           pkg-name*  := <reconstruct-package(|a)> (p', s-pkg')
         ; res        := [pkg-name*, pkg-name]
         else
           res        := [pkg-name]
         end


  this-pkg(|blob) :: Term -> Id * Term
  this-pkg(|a) = ![<id>]; stx-evaluate-with-initial-state(|a, "java/names/PackageNames!thisPkg")
  this-pkg(|a) = stx-get-scopegraph-data(|a, "java/names/PackageNames!thisPkg"); ?[<id>]

  super-pkg(|blob) :: Id * Term -> Id * Term
  super-pkg(|a) = MkSingleton; stx-evaluate-with-initial-state(|a, "java/names/PackageNames!superPkg")

  // inner classes
  reconstruct-enclosing-classes(|blob) :: Id * Term -> List(Id) * Term    
  reconstruct-enclosing-classes(|a): T@(x, s) -> res
    with if <enclosing-class(|a)> T => (x', s') then
           (x*, s'') := <reconstruct-enclosing-classes(|a)> (x', s')
         ; res := ([x*, x], s'')
         else
           res := ([x], s)
         end

  enclosing-class(|blob) :: Id * Term -> Id * Term
  enclosing-class(|a) = Swap; TupleToList; stx-evaluate-with-initial-state(|a, "refret!enclosingClass")

  // Make qualified class reference names

  mk-qualified-class-type(|List(Annotation), TypeArguments-OPT) :: QName -> ClassType
  mk-qualified-class-type(|ann*, tp*): QName([x]) -> ClassType(ann*, x, tp*)

  mk-qualified-class-type(|ann*, tp*): QName(xs) -> ClassOrInterfaceTypeMember(q, ann*, x, tp*)
    with (x*, x) := <split-init-last> xs
       ; q       := <foldl'(mk-top-level-pkg-name, mk-nested-pkg-name)> x*


  mk-top-level-pkg-name = !ClassType([], <id>, NoTypeArguments())
  mk-nested-pkg-name: (x, q) -> ClassOrInterfaceTypeMember(q, [], x, NoTypeArguments())


rules

  rr-create-placeholder(|idx, tgt, a) = oncetd({ sort: 
		  								  where(is-name-of-sort => sort)
		  								; where(somebu(stx--get-ast-index; ?idx))
		  								; rr--lock-reference(|tgt, a, sort)
		  								; rr--create-placeholder(|[tgt])
		  								})

rules

  rr--lock-reference(|decl, solverResult, sort) = prim("RR_lock_reference", decl, solverResult, sort)

  rr--create-placeholder(|ctxts) = prim("RR_create_placeholder", ctxts)

  rr--fix-references(|solverResult) = prim("RR_fix_references", solverResult)


rules

  foldl'(a -> b, a * b -> b|) :: List(a) -> b
  foldl'(s1, s2) = ?[h| tl]; !(tl, <s1> h); foldl(s2)

rules

  dbg :: TP
  dbg(? -> string) :: TP

  dbg       = where(strip-annos; debug)
  dbg(str)  = where(strip-annos; debug(str))
