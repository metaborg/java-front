module refret

imports
  strategolib
  statix/runtime/-
  statix/api

  libstratego-aterm

imports

  signatures/syntax/java/lexical/-
  signatures/syntax/java/names/-
  signatures/syntax/java/types/-
  injections/-

rules

  // Names are hardcoded in current implementation
  implicate-injections-tiger = implicate-injections-java8
  explicate-injections-tiger = explicate-injections-java8

rules

  fix-reference(|ref, tgt): ast -> ast'
    // retrieve original analysis
    with a       := <stx--get-ast-analysis> ast

    // retrieve indices of reference to test
    with ref'    := <collect-ref; collect-id> ref
       ; tgt'    := <collect-ref; collect-id> tgt
       ; ref-idx := <stx--get-ast-index> ref'

    // lock indicated reference, create placeholder and fix!
    with ast'    := < explicate-injections-java8-Start
                    ; rr-create-placeholder(|ref-idx, tgt', a)
                    ; rr--fix-references(|a)
                    ; where(pp-aterm; debug)
                    ; implicate-injections-java8-Start
                    > ast

rules // recognize references, based on syntax/java/names/Names.sdf3

  collect-ref = collect-one(where(strip-annos; is-name-of-sort))

  is-name-of-sort: ClassType(_, _, _) -> "ClassType"
  is-name-of-sort: ClassOrInterfaceTypeMember(_, _, _, _) -> "ClassType"

  is-name-of-sort: PackageName(_) -> "PackageName"
  is-name-of-sort: QPackageName(_, _) -> "PackageName"

  is-name-of-sort: TypeName(_) -> "TypeName"
  is-name-of-sort: QTypeName(_, _) -> "TypeName"

  is-name-of-sort: PackageOrTypeName(_) -> "PackageOrTypeName"
  is-name-of-sort: QPackageOrTypeName(_, _) -> "PackageOrTypeName"

  is-name-of-sort: ExpressionName(_) -> "ExpressionName"
  is-name-of-sort: QExpressionName(_, _) -> "ExpressionName"

  is-name-of-sort: AmbiguousName(_) -> "AmbiguousName"
  is-name-of-sort: QAmbiguousName(_, _) -> "AmbiguousName"

  is-name-of-sort: MethodName(_) -> "MethodName"

  is-name-of-sort: Id(_) -> "Id"

  // Collect rightmost leaf if it is an `Id(_)` term
  collect-id = ?Id(_)
  collect-id = ?ClassType(_, <collect-id>, _)
  collect-id = ?ClassOrInterfaceTypeMember(_, _, <collect-id>, _)
  collect-id = where(is-name-of-sort; not(equal(|"ClassType"))); get-arguments; last; collect-id


rules // qualifier oracle

  qualify-reference(|ctxs, sortName, a): ref -> <debug(!"props: ")> prop*
    with            <debug(!"qualify: ")> ref
       ; [tgt]   := <debug(!"ctxs: ")> ctxs
       ; ref-idx := <collect-id; stx--get-ast-index; debug(!"ref-idx: ")> ref
       ; prop*   := <qualify-class-reference(|tgt, sortName, a); debug(!"q-cls: ") <+ ![(ref, ref-idx)]; debug(!"def: ")> ref

  qualify-class-reference(|tgt, sortName, a): t@ClassType(ann*, x, tp*) -> prop*
    with ref-idx    := <stx--get-ast-index> x
       ; s-tgt      := <stx-get-ast-property(|a, "scope")> tgt
       ; if <stx-get-scopegraph-data(|a, "java/names/PackageNames!thisPkg"); ?[<id>]> s-tgt => (p, s-pkg) then  // FIXME: does this work for nested classes?
	       q-cls    := <reconstruct-package(|a); filter(not(?Id("(unnamed)"))); debug(!"q-pkg: "); mk-qualified-class-type(|ann*, x, tp*)> (p, s-pkg)
	     ; prop*    := [(t, ref-idx), (q-cls, ref-idx)]
         else
           prop*    := [(t, ref-idx)]
         end

  mk-qualified-class-type(|List(Annotation), Id, TypeArguments-OPT) :: List(Id) -> ClassType

  mk-qualified-class-type(|ann*, x, tp*): [] -> ClassType(ann*, x, tp*)

  mk-qualified-class-type(|ann*, x, tp*) = foldl'(mk-top-level-pkg-name; debug(!"tl-pkg: "), mk-nested-pkg-name; debug(!"n-pkg: ")); !ClassOrInterfaceTypeMember(<id>, ann*, x, tp*)

  mk-qualified-class-type(|ann*, x, tp*) = debug(!"cannot match id list: "); fail

  mk-top-level-pkg-name = !ClassType([], <id>, NoTypeArguments())
  mk-nested-pkg-name: (x, q) -> ClassOrInterfaceTypeMember(q, [], x, NoTypeArguments())

  // reconstruct-package(|Analysis) :: Id * Term -> List(Id)

  reconstruct-package(|a): (pkg-name, s-pkg) -> result
    with(if <stx-evaluate-with-initial-state(|a, "java/names/PackageNames!superPkg")> [(pkg-name, s-pkg)] => (p', s-pkg') then
        pkg-name*    := <reconstruct-package(|a)> (p', s-pkg')
      ; result := [pkg-name*, pkg-name]
    else
        result := [pkg-name]
    end)

rules

  foldl'(a -> b, a * b -> b|) :: List(a) -> b
  foldl'(s1, s2) = ?[h| tl]; !(tl, <s1> h); foldl(s2)

rules

  rr-create-placeholder(|idx, tgt, a) = oncetd({ sort: 
		  								  where(is-name-of-sort => sort)
		  								; where(somebu(stx--get-ast-index; ?idx))
		  								; rr--lock-reference(|tgt, a, sort)
		  								; rr--create-placeholder(|[tgt])
		  								})

rules

  rr--lock-reference(|decl, solverResult, sort) = prim("RR_lock_reference", decl, solverResult, sort)

  rr--create-placeholder(|ctxts) = prim("RR_create_placeholder", ctxts)

  rr--fix-references(|solverResult) = prim("RR_fix_references", solverResult)
