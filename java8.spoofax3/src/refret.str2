module refret

imports
  strategolib
  statix/runtime/-

  libstratego-aterm

imports

  signatures/syntax/java/lexical/-
  signatures/syntax/java/names/-
  signatures/syntax/java/types/-
  injections/-

rules

  // Names are hardcoded in current implementation
  implicate-injections-tiger = implicate-injections-java8
  explicate-injections-tiger = explicate-injections-java8

rules

  fix-reference(|ref, tgt): ast -> ast'
    // retrieve original analysis
    with a       := <stx--get-ast-analysis> ast

    // retrieve indices of reference to test
    with ref'    := <collect-ref; collect-id> ref
       ; tgt'    := <collect-ref; collect-id> tgt
       ; ref-idx := <stx--get-ast-index> ref'

    // lock indicated reference, create placeholder and fix!
    with ast'    := < explicate-injections-java8-Start
                    ; rr-create-placeholder(|ref-idx, tgt', a)
                    ; rr--fix-references(|a)
                    ; where(pp-aterm; debug)
                    ; implicate-injections-java8-Start
                    > ast

rules // recognize references, based on syntax/java/names/Names.sdf3

  collect-ref = collect-one(where(strip-annos; is-name-of-sort))

  is-name-of-sort: ClassType(_, _, _) -> "ClassType"
  is-name-of-sort: ClassOrInterfaceTypeMember(_, _, _, _) -> "ClassType"

  is-name-of-sort: PackageName(_) -> "PackageName"
  is-name-of-sort: QPackageName(_, _) -> "PackageName"

  is-name-of-sort: TypeName(_) -> "TypeName"
  is-name-of-sort: QTypeName(_, _) -> "TypeName"

  is-name-of-sort: PackageOrTypeName(_) -> "PackageOrTypeName"
  is-name-of-sort: QPackageOrTypeName(_, _) -> "PackageOrTypeName"

  is-name-of-sort: ExpressionName(_) -> "ExpressionName"
  is-name-of-sort: QExpressionName(_, _) -> "ExpressionName"

  is-name-of-sort: AmbiguousName(_) -> "AmbiguousName"
  is-name-of-sort: QAmbiguousName(_, _) -> "AmbiguousName"

  is-name-of-sort: MethodName(_) -> "MethodName"

  is-name-of-sort: Id(_) -> "Id"

  // Collect rightmost leaf if it is an `Id(_)` term
  collect-id = ?Id(_)
  collect-id = ?ClassType(_, <collect-id>, _)
  collect-id = ?ClassOrInterfaceTypeMember(_, _, <collect-id>, _)
  collect-id = where(is-name-of-sort; not(equal(|"ClassType"))); get-arguments; last; collect-id


rules // qualifier oracle

  qualify-reference(|ctxs, sortName, a) = debug(!"qualify: "); ![(<id>, <collect-id; stx--get-ast-index>)]

rules

  rr-create-placeholder(|idx, tgt, a) = oncetd({ sort: 
		  								  where(is-name-of-sort => sort)
		  								; where(somebu(stx--get-ast-index; ?idx))
		  								; rr--lock-reference(|tgt, a, sort)
		  								; rr--create-placeholder(|[])
		  								})

rules

  rr--lock-reference(|decl, solverResult, sort) = prim("RR_lock_reference", decl, solverResult, sort)

  rr--create-placeholder(|ctxts) = prim("RR_create_placeholder", ctxts)

  rr--fix-references(|solverResult) = prim("RR_fix_references", solverResult)
